<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Controlled AI Christmas Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020202; /* æ·±é‚ƒé»‘èƒŒæ™¯ */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #D4AF37; /* é‡‘å±é‡‘å­—ä½“ */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        .header {
            text-align: left;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6);
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 4px;
            font-size: 24px;
            color: #fff;
            text-transform: uppercase;
        }

        .status-badge {
            display: inline-block;
            margin-top: 10px;
            padding: 5px 12px;
            border: 1px solid #D4AF37;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(5px);
            font-size: 12px;
            letter-spacing: 1px;
            border-radius: 20px;
            color: #D4AF37;
        }

        .controls-area {
            pointer-events: auto;
            margin-top: 20px;
        }

        button.btn-upload {
            background: linear-gradient(45deg, #1A472A, #0f2b19);
            border: 1px solid #D4AF37;
            color: #fff;
            padding: 10px 24px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.4s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 10px rgba(26, 71, 42, 0.5);
        }

        button.btn-upload:hover {
            background: #D4AF37;
            color: #000;
            box-shadow: 0 0 20px #D4AF37;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #video-preview {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1); /* é•œåƒ */
            border: 1px solid #D4AF37;
            border-radius: 8px;
            z-index: 20;
            background: #000;
            object-fit: cover;
            opacity: 0.8;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        /* æŒ‡å¼•é¢æ¿ */
        .instructions {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-left: 3px solid #D4AF37;
            max-width: 300px;
            backdrop-filter: blur(5px);
        }

        .instruction-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-size: 13px;
            color: #eee;
        }

        .instruction-item:last-child { margin-bottom: 0; }

        .icon {
            margin-right: 15px;
            font-size: 20px;
            width: 30px;
            text-align: center;
        }

        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            transition: opacity 1s;
        }
        
        .loader-text {
            color: #D4AF37;
            letter-spacing: 5px;
            margin-top: 20px;
            font-size: 14px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
    
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- External Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div style="width: 50px; height: 50px; border: 2px solid #D4AF37; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        <div class="loader-text">INITIALIZING SYSTEM...</div>
        <style>@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }</style>
    </div>

    <div id="ui-layer">
        <div class="header">
            <h1>LumiÃ¨re NoÃ«l</h1>
            <div class="status-badge" id="status-text">Waiting for Camera...</div>
            <div class="controls-area">
                <input type="file" id="photo-upload" accept="image/*" multiple style="display: none;">
                <button class="btn-upload" onclick="document.getElementById('photo-upload').click()">+ æ·»åŠ ç…§ç‰‡</button>
            </div>
        </div>

        <div class="instructions">
            <div class="instruction-item"><span class="icon">ğŸ‘Š</span> <span>æ¡æ‹³ï¼šèšåˆ (Tree Form)</span></div>
            <div class="instruction-item"><span class="icon">ğŸ–</span> <span>äº”æŒ‡å¼ å¼€ï¼šæ•£å¼€ (Scatter)</span></div>
            <div class="instruction-item"><span class="icon">ğŸ‘‹</span> <span>æ‰‹æŒç§»åŠ¨ï¼šæ—‹è½¬è§†è§’</span></div>
            <div class="instruction-item"><span class="icon">ğŸ‘Œ</span> <span>æåˆï¼šæŠ“å–ç…§ç‰‡ (Zoom)</span></div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <video id="video-preview" playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ================= CONFIGURATION =================
        const CONFIG = {
            colors: {
                green: 0x1A472A,    // å“‘å…‰ç»¿
                gold: 0xFFD700,     // è¾‰ç…Œé‡‘
                red: 0x8B0000,      // åœ£è¯çº¢
                ambient: 0x111111
            },
            particleCount: 600,
            treeHeight: 25,
            treeRadius: 10,
            camZ: 40,
            // Bloom Pass Settings
            bloomStrength: 0.8, 
            bloomThreshold: 0.35 
        };

        const STATE = {
            TREE: 'tree',
            SCATTERED: 'scattered',
            ZOOM: 'zoom'
        };

        // ================= GLOBALS =================
        let scene, camera, renderer, composer, controls;
        let particles = []; // å­˜å‚¨æ‰€æœ‰ 3D å¯¹è±¡çš„æ•°æ®ç»“æ„
        let photoMaterials = []; // å­˜å‚¨ä¸Šä¼ çš„ç…§ç‰‡æè´¨
        let currentState = STATE.TREE;
        let isTransitioning = false;
        let handLandmarks = null;
        let activePhotoIndex = -1; // å½“å‰æ”¾å¤§çš„ç…§ç‰‡ç´¢å¼•
        
        // æ‘„åƒå¤´ & è§†è§‰ç›¸å…³
        const videoElement = document.getElementById('video-preview');

        // ================= INITIALIZATION =================
        async function init() {
            initThree();
            createDefaultTextures(); // åˆ›å»ºä¸€äº›é»˜è®¤çš„â€œç…§ç‰‡â€
            generateParticles();
            setupEvents();
            
            // åˆå§‹åŒ– MediaPipe
            await initMediaPipe();
            
            // éšè— Loading
            document.getElementById('loading').style.opacity = 0;
            setTimeout(() => document.getElementById('loading').remove(), 1000);

            animate();
        }

        function initThree() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.02); // é»‘è‰²é›¾æ°”å¢åŠ æ·±é‚ƒæ„Ÿ

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.camZ);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            // Lighting (è¥é€ ç”µå½±æ„Ÿ)
            const ambientLight = new THREE.AmbientLight(CONFIG.colors.ambient, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(CONFIG.colors.gold, 2);
            mainLight.position.set(10, 20, 10);
            scene.add(mainLight);

            // è¡¥å…‰ï¼šçº¢è‰²å’Œé‡‘è‰²ç‚¹å…‰æº
            const redLight = new THREE.PointLight(CONFIG.colors.red, 2, 50);
            redLight.position.set(-15, 5, 15);
            scene.add(redLight);

            const goldLight = new THREE.PointLight(CONFIG.colors.gold, 1, 50);
            goldLight.position.set(15, -10, 10);
            scene.add(goldLight);

            // Post-Processing (Bloom / Glow)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            
            // æé«˜é˜ˆå€¼ï¼Œé™ä½å¼ºåº¦ï¼Œç¡®ä¿ç…§ç‰‡æ¸…æ™°
            bloomPass.threshold = CONFIG.bloomThreshold; 
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Controls (Fallback mouse interaction)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
        }

        // ================= CONTENT GENERATION =================

        function createDefaultTextures() {
            // åˆ›å»ºç®€å•çš„ Canvas çº¹ç†ä½œä¸ºé»˜è®¤ç…§ç‰‡
            const texts = ["MERRY", "X-MAS", "JOY", "HOPE"];
            texts.forEach((text, i) => {
                const cvs = document.createElement('canvas');
                cvs.width = 512; cvs.height = 512;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = i % 2 === 0 ? '#8B0000' : '#1A472A';
                ctx.fillRect(0,0,512,512);
                ctx.strokeStyle = '#D4AF37';
                ctx.lineWidth = 40;
                ctx.strokeRect(20,20,472,472);
                ctx.fillStyle = '#D4AF37';
                ctx.font = 'bold 100px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 256, 256);
                
                const tex = new THREE.CanvasTexture(cvs);
                tex.colorSpace = THREE.SRGBColorSpace;
                
                // ä½¿ç”¨ç•¥æš—çš„ MeshBasicMaterial ç¡®ä¿æ¸…æ™°åº¦
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, color: 0xCCCCCC });
                photoMaterials.push(mat);
            });
        }

        function generateParticles() {
            // æ¸…ç†æ—§å¯¹è±¡
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            const geoSphere = new THREE.SphereGeometry(0.5, 16, 16);
            const geoBox = new THREE.BoxGeometry(0.7, 0.7, 0.7);
            
            // ç…§ç‰‡çš„åˆå§‹å‡ ä½•ä½“å°ºå¯¸ (åŸºç¡€å°ºå¯¸)
            const geoPlane = new THREE.PlaneGeometry(3.5, 4.375); 

            // æè´¨
            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.9, metalness: 0.1 });
            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                roughness: 0.2, 
                metalness: 1.0, 
                emissive: 0x332200 
            });
            const matRed = new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, roughness: 0.4, metalness: 0.3 });

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh, type;
                const r = Math.random();

                // éšæœºå†³å®šç±»å‹
                if (r < 0.05 && photoMaterials.length > 0) { // 5% æ˜¯ç…§ç‰‡
                    type = 'photo';
                    const mat = photoMaterials[i % photoMaterials.length];
                    mesh = new THREE.Mesh(geoPlane, mat);
                } else if (r < 0.4) { // é‡‘çƒ
                    type = 'gold';
                    mesh = new THREE.Mesh(geoSphere, matGold);
                } else if (r < 0.6) { // çº¢æ–¹å—
                    type = 'red';
                    mesh = new THREE.Mesh(geoBox, matRed);
                } else { // ç»¿çƒå¡«å……
                    type = 'green';
                    mesh = new THREE.Mesh(geoSphere, matGreen);
                }
                
                // é‡ç½®æ‰€æœ‰ç²’å­åˆ°åŸºç¡€ç¼©æ”¾ 1.0
                const baseScale = 1.0;
                mesh.scale.set(baseScale, baseScale, baseScale);

                // 1. è®¡ç®—æ ‘å½¢æ€åæ ‡ (Spiral Cone)
                const p = i / CONFIG.particleCount; // 0 -> 1
                const angle = p * Math.PI * 20; // èºæ—‹åœˆæ•°
                const y = (p * CONFIG.treeHeight) - (CONFIG.treeHeight / 2);
                const radiusAtY = CONFIG.treeRadius * (1 - p); // è¶Šå¾€ä¸Šè¶Šç»†
                
                // åŠ å…¥éšæœºæ‰°åŠ¨ï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶
                const treeX = Math.cos(angle) * radiusAtY + (Math.random()-0.5);
                const treeZ = Math.sin(angle) * radiusAtY + (Math.random()-0.5);
                const treePos = new THREE.Vector3(treeX, y, treeZ);

                // 2. è®¡ç®—æ•£å¼€å½¢æ€åæ ‡ (Random Cloud)
                // ç…§ç‰‡çš„æ•£å¼€èŒƒå›´æ›´å°ï¼Œå½¢æˆç…§ç‰‡äº‘
                const scatterRange = (type === 'photo') ? 20 : 50; 
                const scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * scatterRange,
                    (Math.random() - 0.5) * scatterRange,
                    (Math.random() - 0.5) * scatterRange
                );

                // åˆå§‹ä½ç½®è®¾ä¸ºæ ‘
                mesh.position.copy(treePos);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                
                scene.add(mesh);

                particles.push({
                    mesh: mesh,
                    treePos: treePos,
                    scatterPos: scatterPos,
                    initialScale: mesh.scale.clone(), // å­˜å‚¨åŸºç¡€çš„ 1.0 ç¼©æ”¾
                    type: type,
                    id: i
                });
            }
            
            // ç¡®ä¿åˆå§‹æ¸²æŸ“æ—¶ï¼Œç…§ç‰‡æ˜¯å°çš„ (åœ¨ init å‡½æ•°ä¸­è°ƒç”¨ generateParticles åï¼Œä¼šè°ƒç”¨ animateï¼Œæ­¤æ—¶ currentState æ˜¯ TREE)
            // ç«‹å³è°ƒç”¨ switchState æ¥è®¾ç½®åˆå§‹çš„ç¼©å°çŠ¶æ€
            switchState(STATE.TREE);
        }

        // ================= STATE MANAGEMENT & ANIMATION =================
        // å®šä¹‰ç…§ç‰‡åœ¨ä¸åŒçŠ¶æ€ä¸‹çš„ç¼©æ”¾ä¹˜æ•°
        const PHOTO_TREE_SCALE_MULTIPLIER = 0.6; // èšåˆæ—¶ç¼©å°
        const PHOTO_SCATTER_SCALE_MULTIPLIER = 1.5; // æ•£å¼€æ—¶æ”¾å¤§

        function switchState(newState, targetData = null) {
            // å¦‚æœæ˜¯ TREE çŠ¶æ€ï¼Œä¸”å½“å‰ä¸æ˜¯è¿‡æ¸¡ä¸­ï¼Œåˆ™å¯ä»¥å¿½ç•¥åˆ‡æ¢ï¼Œä½†è¿™é‡Œæˆ‘ä»¬å…è®¸å®ƒè¿è¡Œä»¥ç¡®ä¿åˆå§‹çŠ¶æ€è®¾ç½®æ­£ç¡®ã€‚
            if (currentState === newState && newState !== STATE.ZOOM && isTransitioning === false) return;
            
            isTransitioning = true;
            currentState = newState;
            
            const statusText = document.getElementById('status-text');
            statusText.innerText = `STATUS: ${newState.toUpperCase()}`;
            statusText.style.borderColor = newState === STATE.TREE ? '#D4AF37' : '#fff';

            const duration = 1.5;
            const ease = "power2.inOut";

            // å¦‚æœæ˜¯ Zoom çŠ¶æ€ï¼Œæ‰¾åˆ°ä¸€å¼ ç…§ç‰‡ä½œä¸ºç›®æ ‡
            let zoomTargetParticle = null;
            if (newState === STATE.ZOOM) {
                const photoParticles = particles.filter(p => p.type === 'photo');
                if (photoParticles.length > 0) {
                    // éšæœºé€‰æ‹©ä¸‹ä¸€å¼ ç…§ç‰‡
                    const nextIndex = Math.floor(Math.random() * photoParticles.length);
                    zoomTargetParticle = photoParticles[nextIndex];
                } else {
                    switchState(STATE.SCATTERED);
                    return;
                }
            }

            particles.forEach(p => {
                let targetPos;
                let targetScale = p.initialScale.clone(); // åŸºç¡€ç¼©æ”¾ (1.0)
                let targetRot = {x: 0, y: 0, z: 0};

                if (newState === STATE.TREE) {
                    targetPos = p.treePos;
                    // èšåˆçŠ¶æ€ï¼šç…§ç‰‡ç¼©å°
                    if (p.type === 'photo') {
                        targetScale.multiplyScalar(PHOTO_TREE_SCALE_MULTIPLIER);
                    }
                } else if (newState === STATE.SCATTERED) {
                    targetPos = p.scatterPos;
                    // æ•£å¼€çŠ¶æ€ï¼šç…§ç‰‡æ”¾å¤§
                    if (p.type === 'photo') {
                        targetScale.multiplyScalar(PHOTO_SCATTER_SCALE_MULTIPLIER);
                    }
                } else if (newState === STATE.ZOOM) {
                    if (p === zoomTargetParticle) {
                        // æ”¾å¤§æ˜¾ç¤ºåœ¨å±å¹•ä¸­é—´
                        
                        // 1. ç›®æ ‡ä½ç½®ï¼šç¨å¾®é è¿‘ç›¸æœºï¼Œå æ®å±å¹•ä¸­å¤®
                        const vector = new THREE.Vector3(0, 0, -5); 
                        vector.applyQuaternion(camera.quaternion);
                        vector.add(camera.position);
                        targetPos = vector;
                        
                        // 2. ç›®æ ‡ç¼©æ”¾ï¼šåœ¨åŸºç¡€å°ºå¯¸ä¸Šå†æ”¾å¤§ 4 å€
                        targetScale.multiplyScalar(4);
                        
                        // 3. ç›®æ ‡æ—‹è½¬ï¼šé¢å‘ç›¸æœº
                        targetRot = { 
                            x: camera.rotation.x, 
                            y: camera.rotation.y, 
                            z: camera.rotation.z 
                        };
                    } else {
                        // å…¶ä»–ç²’å­ï¼šä¿æŒæ•£å¼€çŠ¶æ€çš„è·ç¦»å’Œå¤§å°
                        targetPos = p.scatterPos;
                        if (p.type === 'photo') {
                             targetScale.multiplyScalar(PHOTO_SCATTER_SCALE_MULTIPLIER);
                        }
                    }
                }

                // ä½ç½®åŠ¨ç”»
                gsap.to(p.mesh.position, {
                    x: targetPos.x, y: targetPos.y, z: targetPos.z,
                    duration: duration,
                    ease: ease
                });

                // ç¼©æ”¾åŠ¨ç”»
                gsap.to(p.mesh.scale, {
                    x: targetScale.x, y: targetScale.y, z: targetScale.z,
                    duration: duration,
                    ease: ease
                });

                // æ—‹è½¬åŠ¨ç”»
                if (newState === STATE.ZOOM && p === zoomTargetParticle) {
                    gsap.to(p.mesh.rotation, {
                        x: targetRot.x, y: targetRot.y, z: targetRot.z,
                        duration: duration
                    });
                } else if (newState !== STATE.TREE) {
                    // æ•£å¼€æ—¶éšæœºæ—‹è½¬
                    gsap.to(p.mesh.rotation, {
                        x: Math.random()*Math.PI, y: Math.random()*Math.PI,
                        duration: duration
                    });
                }
            });

            // ç›¸æœºåŠ¨ç”» (æ ‘çŠ¶æ€å¤ä½ç›¸æœº)
            if (newState === STATE.TREE) {
                gsap.to(camera.position, {
                    x: 0, y: 0, z: CONFIG.camZ,
                    duration: duration
                });
                gsap.to(camera.rotation, { x: 0, y: 0, z: 0, duration: duration});
            }

            setTimeout(() => { isTransitioning = false; }, duration * 1000);
        }

        // ================= MEDIAPIPE & GESTURE LOGIC =================

        async function initMediaPipe() {
            try {
                // MediaPipe Hands and Camera initialization remains the same
                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });

                hands.onResults(onHandsResults);

                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 320,
                    height: 240
                });
                
                await cameraUtils.start();
            } catch (err) {
                console.error("MediaPipe Init Failed:", err);
                document.getElementById('status-text').innerText = "Camera Error: Please allow access";
            }
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks[0];
                detectGesture(handLandmarks);
            } else {
                handLandmarks = null;
            }
        }

        function detectGesture(landmarks) {
            // å…³é”®ç‚¹: 0=è…•, 4=æ‹‡æŒ‡å°–, 8=é£ŸæŒ‡å°–
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18]; // è¿‘æŒ‡å…³èŠ‚

            // 1. è®¡ç®—æ‰‹æŒ‡ä¼¸å±•æ•°é‡ 
            let openFingers = 0;
            tips.forEach((tipIdx, i) => {
                const pipIdx = pips[i];
                const tipDist = Math.hypot(landmarks[tipIdx].x - wrist.x, landmarks[tipIdx].y - wrist.y);
                const pipDist = Math.hypot(landmarks[pipIdx].x - wrist.x, landmarks[pipIdx].y - wrist.y);
                if (tipDist > pipDist * 1.1) openFingers++;
            });
            // æ‹‡æŒ‡å•ç‹¬å¤„ç†
            const thumbTip = landmarks[4];
            if (Math.hypot(thumbTip.x - landmarks[5].x, thumbTip.y - landmarks[5].y) > 0.05) openFingers++;

            // 2. æ£€æµ‹æåˆ (Pinch) - æ‹‡æŒ‡å°–ä¸é£ŸæŒ‡å°–è·ç¦»
            const pinchDist = Math.hypot(thumbTip.x - landmarks[8].x, thumbTip.y - landmarks[8].y);
            const isPinching = pinchDist < 0.04;

            // --- çŠ¶æ€æœºé€»è¾‘ ---

            if (isPinching) {
                // æåˆ -> æ”¾å¤§ç…§ç‰‡
                if (currentState !== STATE.ZOOM && !isTransitioning) {
                    switchState(STATE.ZOOM);
                }
            } else if (openFingers <= 1) {
                // æ¡æ‹³ (0 æˆ– 1 æŒ‡) -> æ ‘çŠ¶æ€
                if (currentState !== STATE.TREE && !isTransitioning) {
                    switchState(STATE.TREE);
                }
            } else if (openFingers >= 4) {
                // å¼ å¼€æ‰‹ (4 æˆ– 5 æŒ‡) -> æ•£å¼€çŠ¶æ€
                if (currentState !== STATE.SCATTERED && !isTransitioning) {
                    switchState(STATE.SCATTERED);
                }
                
                // æ—‹è½¬æ§åˆ¶é€»è¾‘ï¼šå½“å¤„äº Scatter çŠ¶æ€æ—¶
                if (currentState === STATE.SCATTERED) {
                    // ä½¿ç”¨æ‰‹æŒä¸­å¿ƒ X åæ ‡æ§åˆ¶æ—‹è½¬
                    const palmX = landmarks[9].x; 
                    const rotationSpeed = (palmX - 0.5) * 0.05;
                    scene.rotation.y += rotationSpeed; // ç›´æ¥æ—‹è½¬åœºæ™¯
                }
            }
        }

        // ================= MAIN LOOP =================

        function animate() {
            requestAnimationFrame(animate);

            // é»˜è®¤è‡ªåŠ¨æ—‹è½¬ 
            if (currentState === STATE.TREE && !isTransitioning) {
                scene.rotation.y += 0.002;
                // ç²’å­è½»å¾®æµ®åŠ¨
                const time = Date.now() * 0.001;
                particles.forEach((p, i) => {
                    if (p.type !== 'photo') {
                         p.mesh.position.y += Math.sin(time + i * 0.1) * 0.005;
                    }
                });
            } else if (currentState === STATE.ZOOM) {
                // Zoom çŠ¶æ€ä¸‹èƒŒæ™¯ç¼“æ…¢æµåŠ¨
                scene.rotation.y += 0.0005;
            }

            controls.update();
            composer.render();
        }

        // ================= UTILS & EVENTS =================
        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // å›¾ç‰‡ä¸Šä¼ å¤„ç†
            document.getElementById('photo-upload').addEventListener('change', (e) => {
                if (e.target.files && e.target.files.length) {
                    Array.from(e.target.files).forEach(file => {
                        const reader = new FileReader();
                        reader.onload = (evt) => {
                            const img = new Image();
                            img.src = evt.target.result;
                            const tex = new THREE.TextureLoader().load(img.src);
                            tex.colorSpace = THREE.SRGBColorSpace;
                            // æ·»åŠ æ–°æè´¨åˆ°åˆ—è¡¨å¼€å¤´ (ä½¿ç”¨ç•¥æš—çš„ MeshBasicMaterial ç¡®ä¿æ¸…æ™°åº¦)
                            const newMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, color: 0xCCCCCC });
                            photoMaterials.unshift(newMat);
                        };
                        reader.readAsDataURL(file);
                    });
                    
                    // æç¤ºé‡æ–°ç”Ÿæˆ
                    setTimeout(() => {
                        generateParticles(); // é‡æ–°ç”Ÿæˆç²’å­ä»¥åº”ç”¨æ–°ç…§ç‰‡
                        // ä¸éœ€è¦è°ƒç”¨ switchState(STATE.TREE)ï¼Œå› ä¸º generateParticles å·²ç»åšäº†ã€‚
                    }, 1000);
                }
            });
        }

        // Start
        window.onload = init;
    </script>
</body>
</html>